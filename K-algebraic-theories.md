This is an attempt to provide a formalism similar to that of algebraic theories, for definitions of K-algebras over a generalised field `K`. We will be keeping in mind two kinds of generalised fields: the classical fields and the "field with one element" as defined by A. Connes in [Co1].

Algebraic theories with the linearity restriction (every variable used exactly once in the conclusion) and depndent sorts: for any positive integer number of vectors (variables earlier in the context or functions of them) `x,..,z`of the same type we have a type Span{x,..,z} -- a vector space spanned by `x,..,z`. May have multiple outcomes, possibly dependent on the premises. Over F1 e : Span(x//z) is only possible if all nonzero elements are equal, and there is at least one nonzero element. So, it essentlally boils down to equality over the type.

```
 a b : Nat'
------------
    ab

 a b : Nat'   {a, zero}
------------------------
         {ab}

 a b : Nat'   {b, zero}
------------------------
         {ab}



 a b : Nat'
---------------
 f(a,b) : Nat'

 x : X   {f(x), g(x)}
-------------------
   f|g : Y
   
```

§ Fields with partially defined addition
----------------------------------------

Classically, a field `F` is a set with two commutative monoidal operations called addition (`+`) and multiplication (`*`) respectively, so that each element has an additive inverse, each element besides 0 (the empty sum) has multiplicative inverse, and addition distributes over multiplication. It is additionally requred that empty product 1 is distinct from the empty sum 0.

In case of generalised fields, the addition is allowed to be a partial operation. In particular, one can define a class of generalised fields, where a string of elements is summable if it has at most one nonzero element, and consider the minumal case with elements 0 and 1 with following operations:

```
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = non applicable

-(0) = 0
-(1) = non applicable

0 * 0 = 0
0 * 1 = 0
1 * 0 = 0
1 * 1 = 1

0 / 1 = 0
1 / 1 = 1
x / 0 = non applicable
```

This field has only one classical element, the 0. The 1 is called and ephemerial element (see later). For this reason (and many others going far off the scope of this paper), this "field" is known by the name "field with one element".

A vector space `V` over a generalised field `F` is a set equiped with an `n`-ary operation called "linear combination" for each summable string of elements of `F` of length `n`, so that linear combination distrubute over themselves. For a field with totally defined addition this clearly replicates the usual definition of vector spaces. For the field with one elements, vector spaces are sets with selected element `⊥` (the empty linear combination). Multiplying any element by scalar 1 does not change it while multiplying by 0 maps it to ⊥. Basis is given by non-⊥ elements of the set, 1-dimensional subspaces are precisely subsets formed by ⊥ and one other element. Subspaces generated by two or more non-⊥ elements are empty (non-emptiness is incompatible with partially defined addition in F1). Linear maps are precisely the maps that map ⊥ to ⊥ and do whatever they want to other elements, thus the monoidal category Vect_F1 is the category of pointed sets with smash product as tensor product (bilinear map is precisely a function that yields ⊥ whenever one of its arguments is ⊥, so tensor product is simply a cartesian product of underlying sets with (any, ⊥) and (⊥, any) identified and made its ⊥). As with proper vector space categories, this one has a zero object and is symmetrically monoidal closed, with tensor product distributive over coproducts, which are given by direct sums (adjoining the bases of underlying sets regardless of their cardinality). In sharp contrast to proper categories of vector spaces, products do not coinscide with coproducts even in case of finite arity (> 1):
```
A x B = A + B + AB
A x B x C = A + B + C + AB + BC + CA + ABC
...
```




§ Category of Sets and Partial Maps seen as Vect_F1
---------------------------------------------------

In computer science, each well-typed programming language "L" defines a category of data types and well-formed programs as maps between them. Due to halting problem, each language either misses some computable maps (i.e. some of the computable maps cannot be expressed in the given language), or allows some well-typed programs that never yield a result in some cases (i.e. never "halt"), in the latter case one has to do with a category of sets and partial maps between them.

The category of sets and maps functions can be seen as a category of pointed sets and with point-preserving (total) maps. It is, sets are augmented with additional "sticky element" `⊥` and programs that never halt are formally assumed to return the "non-value" `⊥`. The "stickiness", means that each map returns `⊥` when applied to `⊥`: a function applied to an argument that would not evaluate in a finite time will also not evaluate in a finite time.

But what about functions of multiple alguments? Let's start with the two-argument case. In the simplest case, the function can only deliver a result if both arguments are available. But consider the multiplication function on the natural numbers: if it is known that the first argument is zero, it doesn't even inspect the second one, so it yields a result even if evalution of the second argument would never stop. If you have two functions of the same arguments, and it is known that their results agree when both halt, we have an operation of "concurrent evaluation" f|g: it starts evaluation in parallel and yield whichever computes first. In this manner using the fact that multiplication is commutative, we can concurrently evaluate multiplication and its argument reversed form. Then we'll obtain a function that halts not only when its arguments halt, but also if any of its arguments evaluates to zero.

We need an algebraic framework enabling such reasoning:




§ Partial Horn Theories
-----------------------

The eminent paper of Palmgren and Vickers “Partial Horn Theories and Cartesian Categories” defines a logic where

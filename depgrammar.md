<h2>§ Introduction</h2>

<h3>§§ Algebraic Theories and Dependently Typed Languages</h3>

Mathematical facts (theorems) are stated and proven inside of a respective axiomatic theory, e.g. Euclidean geometry. For sake of reusability and composability of mathematical results, generic mathematicians<sup>[^1]</sup> usually work inside of the axiomatic theory of vast generality known as Zermelo–Fraenkel set theory, into which more specialised axiomatic theories (like theory of groups) are submerged. However, it makes a lot of sense to study specialised axiomatic theories in their own right.

An axiomatic theory is defined upon a chosen underlying logic (usually, classical first order logic unless stated otherwise) and is given by
– a language in which propositions of the theory are stated (the language of the underlying logic extended by theory-specific syntax), and
– a finite or recursively generated set of axioms in this language, i.e. propositions assumed to be true a priori in this particular theory.

A logic consists of a common language base for axiomatic theories stated upon this logic, and language for proofs specific to this logic. There is more than one way to define what a language is, but we will assume that these languages are given in terms of formation rules<sup>[^2]</sup> (also called “derivation rules” in case of a proof language) that can be used to generate a set of unambiguous expressions being valid propositions and correct proofs respectively.

<figure><b>Fig. 1: Examples of formation and derivation rules.</b>
<pre>```
 A : Prop   B : Prop       A : Prop   B : Prop   x : Pf[A]    y : Pf[A => B]
—————————————————————     ———————————————————————————————————————————————————Modus Ponens
    A => B : Prop                           MP(x,y) : Pf[B]

```</pre></figure>
<lj-cut>Equational logic can be seen as a weak fragment of classical first order logic where the only axioms allowed are universally-qualified equational laws. Thus theories based upon equational logic cannot express any properties of non-functional relations, in particular incidence relations, order relations and partially defined operations (like division in fields and division rings). For this reason for theories defined upon equational logic, theory specific syntax is limited to a fixed number of functional symbols of fixed arities (symbols of arity zero being called constants). Theory-specific syntax is usually described precisely in the form we used in Fig. 1 above, as formation rules for terms of the theory.

Lots of interesting axiomatic theories including theory of groups, theory of rings and theory of modules over a ring can be stated and studied upon equational logic. Proofs in equational logic are limited to algebraic manipulations (transforming symbolic expressions using equalities to prove other equalities). For this reason, such theories are known as <a href="https://ncatlab.org/nlab/show/algebraic+theory">algebraic theories</a>. Algebraic theories have <a href="https://ncatlab.org/nlab/show/Functorial+Semantics+of+Algebraic+Theories">exceptionally elegant and well-understood model theory</a>, and <a href="https://en.wikipedia.org/wiki/Variety_(universal_algebra)#Birkhoff&#39;s_theorem">most well-behaved correspondence between syntax and semantics</a>.

<figure><b>Fig. 2: Example of a single-sorted algebraic theory.</b>
<pre>```
 x   y                     x             x
————————    —————     ———————————   ———————————
 [x,y]        e        [e,x] = x     [x,e] = x

```</pre></figure>
All irreducible provable propositions in equational logic are universally qualified and of the form “term₁ = term₂” or “(a = b) ⋀ ··· ⋀ (c = d) ⇒ (x = y)”. Thus, equational logic can be also seen as a logic in its own right with a very tractable proposition and proof languages. Whereas in full first order logic, propositions are arbitrary combinations of nested quantifiers and connectives, in equational logic propositions have a very rigid form, so that quantifiers and connectives can be leaved implicit and not part of the language, a proposition can be described by a nonempty list of equations of finite length, where terms (sides of equalities) are generated by formation rules of the theory and possibly a number of variables. Proof language of equational logic is also vastly simpler: equations can be generated by reflexivity, transformed by symmetry, composed by transitivity and used for algebraic transformations, a proof is just a tree of such steps.

An algebraic theory is a grammar + equational laws between terms generated by the grammar. Grammar of an algebraic theory is allowed to be multisorted (e.g. there two distinct types of variables and terms: “scalars” and “vectors”). Such grammars are however not general enough to describe proposition and proof languages for a logic. A grammar for a proof language (see Fig. 1) is necessarily not just multisorted, but dependently typed: there are types with indexes like `Pf[p]` standing for “Proof of proposition `p`”. Moreover, a if language of propositions has (at least implicit) quantifiers (which is the case for every logic beyond zeroth-order) and also has a dependently typed grammar: besides type `Prop` of closed propositions there have to be types `Pred[ctx]` of predicates of several of variables (where the “context” ctx specifies the number and types of variables).

To make sense of a dependently typed grammar, one has to rely a certain notion of equality[^2] on indexes of the types. Moreover, when two occurrences of typal dependency (`Proof[prop]` and `Prop[ctx]`) come into interaction, equality cannot by swept under the rug: in order to define proposition and proof languages for logics, we have to provide their grammars together with some additional equational laws; the framework to describe sufficiently elaborate grammars is necessarily a generalisation of algebraic theories' framework.

Ultimately, it is desired to obtain a framework of extended algebraic theories, so that each conventional logical system can be expressed as an extended algebraic theory and an axiomatic theory upon this system as its free algebra generated by sort definitions, term formation rules and axioms of the theory. The framework should support at least classical and intuitionistic first order logic (including FOLDS = first order logic with dependent sorts), equational logic (optimally, it should “eat itself”) and encompass an algebraic definition of an elementary ∞-topos, which is a modern foundational alternative to Zermelo–Fraenkel set theory.

Establishing of an all-encompassing framework of this kind with a nice semantics is however still work-in-progress. Present work is an attempt to progress in this direction.

[^1]: <i>A generic mathematician, or more precisely a generic pure mathematician, is a mathematician working in the areas of algebra, analysis, geometry, topology or number theory, using classical logic and the axiom of choice.</i> — David M Roberts, hott.zulipchat.com

[^2]: Actually, instead of equality a more general notion of canonical convertibility can be developed for this case.

<h3>§§ The Equality Problem</h3>
In the framework of algebraic theories (both <a href="https://ncatlab.org/nlab/show/Lawvere+theory">single-sorted</a> or <a href="https://ncatlab.org/toddtrimble/published/multisorted+Lawvere+theories">multisorted</a> with a fixed finite collection of sorts), equations are imposed upon grammar and not intertwined with it. In order to construct an initial model, one just generates the set of terms from the grammar and factors it by equations. In this framework there is also no notion of equality on sorts except for the purely syntactic notion of nominal equality (equally named sorts are equal).

It gets more tricky if one extends the framework to accommodate dependently-typed formation rules. In such theories sorts are generalised to types which are in general dependent on values of other types, say `Mat[n, m]` of `(n × m)`-matrices, which can be multiplied only if dimensions match. In such cases one speaks of sort `Mat` with two indexes of type `Nat`. The concrete type is given by sort and fixed values for all of its parameters, e.g. `Mat[3, 3]`. With dependent types we run into a problem: in order to see if a term of type `T[x]` fits into a receptacle of type `T[x']` we need to be able to check if `x = x'`, and it might even happen that `x : G[y]` and `x' : G[y']` so that we need to check if `y = y'` even to start checking if `x = x'`.

Unless we restrict allowed dependency structure, we might run into situation where a circular dependency makes the question if a term fits into a receptacle (i.e. if a given word is a syntactically valid term) not only undecidable but not even semidecidable, and the very existence of the initial model can be shown only with help of the highly non-constructive well-ordering principle (= axiom of choice). A theory without a tractable syntactical model can hardly be named algebraic. For a theory describing a proof language such situation is unacceptable: a proof language where it is in general inherently impossible to find out if a proof is valid is worthless.

A workable solution is to distinguish indexing sorts, which are either free sorts (sorts with no equations whatsoever) or sorts with canonical forms (with arguments of indexing sorts only), and to restrict conditions in premises of formation rules to equalities over indexing sorts.

In the following we'll start with a broad generalisation of algebraic theories and restrict it step-by-step while refining its semantics at the same time.

<h2>§ Essentially Algebraic Theories</h2>
{TODO: Exposition}


<h2>§ Algebraic Theories with Index Sorts</h2>
Algebraic theories with index sorts are a special case of EATs, where some sorts are marked as index sorts and there is an additional kind of formation rules: formation rules of “canonical forms” written with `term ↪ T` instead of `term : T` below the rule. Canonical forms have to map from and into index sorts only.

The only conditions allowed in algebraic theories with index sorts are of the form `t = c` where `t` is a (noncanonical) term of index type and `c` is a canonical form of the same type. All equational rules in index sorts also must be of this form. Every (noncanonical) formation rule into an index sort must come with a number of equational rules allowing to unambiguously find an equal a canonical form for a term whenever arguments of canonical form are substituted. These rules are called computation rules. No other equational rules in index sorts are allowed. In particular, index sorts with no canonical forms have to be free (no equations allowed).

Here is an example:

<pre>```
                            n : Nat
—————————    ——————————    —————————
 Nat idx      0 ↪ Nat      n' : Nat

 n : Nat    m : Nat
————————————————————
     n + m : Nat

  n : Nat    m : Nat   n = 0
—————————————————————————————
    n + m = m             

 n : Nat    m : Nat    k : Nat    n = k'
—————————————————————————————————————————
        n + m = (k + m)'
```</pre>

Injective sorts are helpful when one wants to define dependent sorts like `Mat[n, m]` of `(n × m)`-matrices or `Pred[n]` of predicates with `n` untyped variables or `Pred[ctx]` of predicates in context `ctx`, where context is a finite list of types of variables.

Index sorts are normally intended to be “closed”, i.e. not to be extended in models. Index sorts which are explicitly allowed to be extended (yet only freely) in models are called abstract.

Example:

<pre>```
————————    —————————
 Ob abs      Ctx idx

                   tail : Ctx    head : Ob
——————————————    —————————————————————————
 empty ↪ Ctx         (tail; head) ↪ Ctx

 a : Ctx    b : Ctx
————————————————————
 append(a, b) : Ctx


 a : Ctx    b : Ctx    b = empty
—————————————————————————————————
 append(a, b) = b

 a : Ctx    b : Ctx    tail : Ctx     head : Ob    b = (tail; head)
————————————————————————————————————————————————————————————————————
 append(a, b) = (append(a, tail); head)

```</pre>

We'll introduce a refined semantics for Algebraic Theories with Index Sorts: namely, we do not want to distinguish between models which differ by inaccessible or indistinguishable elements of index types. This will ultimately lead to notion of equivalence of categories for algebraic theory of categories.


<h2>§ Algebraic Theories with Index and Indexed Sorts</h2>
In this extensions, each sort may additionally have a fixed number of named indexes, e.g. `Mat[width : Nat, height : Nat]`. Types of indexes are not limited to index types, but only indexes of index types can be used in conditions of formative rules. Equational laws are allowed only if indices of left hand side and right hand side are equal (either nominally, or by application of computation rules).

Every formative rule must be supplied by equations expressing indices of outcome in terms of indices of its constituents. These can be included into the formative rule as in the following example:

<pre>```
                            n : Nat
—————————    ——————————    —————————
 Nat idx      0 ↪ Nat      n' : Nat

————————————————————————————————
 Mat[height : Nat, width : Nat]

 a : Mat   b : Mat   a.height = b.width
————————————————————————————————————————
   ab : Mat[a.height, b.width]
```</pre>

Algebraic Theories with Index and Indexed Sorts where the only index types are free types are syntactically precisely the <a href="https://ncatlab.org/nlab/show/generalized+algebraic+theory">Generalised Algebraic Theories</a> without sort equation. For readers with CS background, initial algebras of such theories can be expressed the closed Quotient-Inductive-Inductive Types[https://arxiv.org/abs/1612.02346] and set-valued models as their (non-dependent, set-level) elimination motives.

Example: Definition of Semicategories
<pre>```
————————    ———————————————————————————————
 Ob abs      Map[source : Ob, target : Ob]

 f : Map    g : Map    f.target = g.source
———————————————————————————————————————————
     fg : Map[f.source, g.target]

 f : Map    g : Map    h : Map    f.target = g.source    g.target = h.source
—————————————————————————————————————————————————————————————————————————————
               f(gh) = (fg)h
```</pre>

Initial algebras for generic Algebraic Theories with Index- and Index-Dependent Sorts are the closed Quotient-Inductive-Inductive-Recursive Types, the non-canonical formation rules for index types with their respective computation rules taking them to the canonical ones are turned into internal recursive functions.

Algebraic Theories with Index- and Index-Dependent Sorts can be used to define language of propositions for logics. Let's start with the case of single-sorted underlying theory. 

Example: Language of propositions for minimal logic 
<pre>```
@import Nat

——————————————— Type of terms with `n` variables
 Term[n : Nat]

 t : Term[n]
———————————————— Terms with `n` variables are included into terms with `n + 1` variables
 t' : Term[n']

 n : Nat
——————————————————— Reference to `n`'th variable is valid term with `n` variables
 var(n) : Term[n']

{Here the theory-specific formation rules for terms come
For example, if the theory provides a constant `c`, we'll have

——————————
 c : Term

If the theory provides a binary operation of addition, we'll have

 n : Nat   t1 : Term[n]    t2 : Term[n]
——————————————————————————————
     t1 + t2 : Term[n]
}

Now the atomic predicates are defined:

 n : Nat    t1 : Term[n]    t2 : Term[n]
—————————————————————————————————————————
      equals(t1, t2) : Pred[n]

{If the theory has additional relations besides equality, add an analogous theory-specific rule for each of them.}

Logical connectives:

 n : Nat   a : Pred[n]    b : Pred[n]
——————————————————————————————————————
        a => b : Pred[n]

 n : Nat   a : Pred[n]    b : Pred[n]
——————————————————————————————————————
        a ⋀ b : Pred[n]

 n : Nat   a : Pred[n]    b : Pred[n]
——————————————————————————————————————
        a ∨ b : Pred[n]

    n : Nat
——————————————
 ⊥ₙ : Pred[n]

Quantifiers:

 n: Nat   p : Pred[n']
———————————————————————
    ∀p : Pred[n]

 n: Nat   p : Pred[n']
———————————————————————
    ∃p : Pred[n]
```</pre>

Now let's move to the version for many-sorted theories. First, in addition to the type `Nat` of natural numbers (we'll need that for `var(n) : Term[n']`) we'll define the type `Ctx[n : Nat]` of contexts of length `n`, i.e. lists of types of variables. It will be defined upon abstract type `Ob` of theory-specific sorts. `Ctx[n : Nat]` makes substantial use of the feature that index types can be indexed themselves.

<pre>```
                            n : Nat
—————————    ——————————    —————————
 Nat idx      0 ↪ Nat      n' : Nat

 n : Nat    m : Nat
————————————————————
     n + m : Nat

  n : Nat    m : Nat   n = 0
—————————————————————————————
    n + m = m             

 n : Nat    m : Nat    k : Nat    n = k'
—————————————————————————————————————————
        n + m = (k + m)'


————————    ———————————————————————
 Ob abs      Ctx[length : Nat] idx

                         tail : Ctx    head : Ob
—————————————————    ——————————————————————————————————
 empty ↪ Ctx[0]      (tail; head) ↪ Ctx[tail.length']

 a : Ctx    b : Ctx
—————————————————————————————————————————
 append(a, b) : Ctx[a.length + b.length]


 a : Ctx    b : Ctx    b = empty
—————————————————————————————————
 append(a, b) = b

 a : Ctx    b : Ctx    tail : Ctx     head : Ob    b = (tail; head)
————————————————————————————————————————————————————————————————————
 append(a, b) = (append(a, tail); head)

```</pre>

In our applications, we'll encounter countless cases of sorts with precisely these two projections (`source` and `target` or `context` and `type`), so it makes sense to introduce a shorthand notation (which is already very common among type theorists):
- Let `src ⊢₍ArrowSort₎ f : tgt` always denote `f : ArrowSort[source = src, target = tgt]`. In many cases we'll have multiple types of “arrow sorts” such as functors and proarrows or 1-cells and 2-cells. We use turnstile without subscript `⊢` if only one such sort exists in the given theory, or reserve it for the sort named “Map” otherwise.
— Analogously, we'll use `ctx ⊢ p Prop` for `p : Prop[ctx]`
– Let's write `a b .. c : T` instead of `a : T   b : T   ...   c : T` when we have multiple arguments of the same sort.

——————————————————————— Type of terms in a context
 Term[Г : Ctx, T : Ob]

Г : Ctx    R : Ob    Г ⊢ t : T
———————————————————————————————
    Г; R ⊢ tᴿ : T

    Г : Ctx    T : Ob
———————————————————————————
 Г; T ⊢ var(Г.length) : T

{Here the theory-specific formation rules for terms come.}

Now the atomic predicates are defined:

 Г : Ctx     Г ⊢ t1 t2 : T
————————————————————————————
 Ctx ⊢ equals(t1, t2) Pred

{If the theory has additional relations besides equality, add an analogous theory-specific rule for each of them.}

Logical connectives:

 Г : Ctx    Г ⊢ a b Pred
———————————————————————————
    Г ⊢ a => b Pred

{...}

Quantifiers:

 Г : Ctx    R : Ob    Г; R ⊢ p Pred
————————————————————————————————————
          Г ⊢ ∀ᴿp Pred

 Г : Ctx    R : Ob    Г; R ⊢ p Pred
————————————————————————————————————
          Г ⊢ ∃ᴿp Pred

```

The shorthand notation is also very handy for definition of categories:
```
 X Y Z : Ob    X ⊢ f : Y    Y ⊢ g : Z 
——————————————————————————————————————
           X ⊢ fg : Z 

    O : Ob           X Y : Ob    X ⊢ f : Y
————————————————    ———————————————————————
 O ⊢ id₍O₎ : O       id₍X₎ f = f = f id₍Y₎

 A B C D : Ob    A ⊢ f : B    B ⊢ g : C    C ⊢ h : D 
——————————————————————————————————————————————————————
                   f(gh) = (fg)h 
```

<h2>Staged equality</h2>

<h2>Internalising types: The Bi-directional Doctrine</h2>

Let's define a category with binary products
```
@import Cat

  A B : Ob
—————————————
 A × B ↪ Ob


 X A B : Ob    X ⊢ f : A × B
—————————————————————————————
     X ⊢ f.fst : A


 X A B : Ob    X ⊢ f : A × B
—————————————————————————————
     X ⊢ f.snd : B

                            p : Pair[O X Y]
———————————————————————    =================
 Pair[O X Y : Ob] ind        O ⊢ p : X × Y




```

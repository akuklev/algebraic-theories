Towards Higher Observational Calculus of Constructions
======================================================

We propose (a sketch of) an extension HOCC of the Higher Observational Type Theory (HOTT) by parametric quantifiers, a first-class notion of Reedy categories and inductive type families indexed and fibered above them enabling flawless handling of higher categorical objects and naturally occuring seemingly large categories. This extension provides simplicial types and other Reedy presheaf types without reccuring to any kind of non-univalent equality.

Purely inductive type families indexed and fibered over simultaneously defined Reedy categories correspond precisely to bidirectional presentations of dependent type theories and allow to develop functorial semantics of their models. This justifies viewing type-theoretic presentations of weak Ï‰-categories (by E. Finster, S. Mimram et al.) and virtual equipments (by M. New, D. Licata) as extended algebraic definitions.

This work heavily builds upon (mostly unpublished) ideas of C. McBride.

Â§ Introduction
--------------

In type theory, inductive types are the types freely generated by a set of possibly recursive generators:
```
#Inductive Nat
  0    : Nat
  (_') : Nat â†’ Nat
```

Here the type `Nat` is introduced as the type freely generate by one non-recursive generator `0` satisfying type `Nat` and a recursive generator `(_')` (writen as a postifx apostrophe) satisfying type `Nat â†’ Nat`. With this definition, the set of possible Nat-values is given by  
  `0, 0', 0'', 0''', ...`  
Readers more versed with general purpuse programming languages than with type theory might assume that 0 is a literal inbuilt into the language and `(_')` is a function defined behind the scenes that acts on some technical representation of natural numbers, yet that's not what happening here. Both `0` and `(_')` are introduced right here as generators of the type `Nat`. They are â€œstatic symbolsâ€ that represent nothing other than themselves and are irreducible.

Inductive types may have typal parameters (these are enclosed in square brackets):
```
#Inductive List[\T]
  Empty : List[T] 
  (::)  : T â†’ (List[T] â†’ List[T])
```

This definition introduces the polymorphic type `List[T]` parametrized by the type `T` of its elements. The backslash in `\T` in the first line is the so called â€œfreshness sigilâ€, it is there to express that `T` is not a constant that was defined somewhere else, but a fresh variable being introduced at this very spot. The second line introduces a rather boring generator `Empty` of `List[T]`, much like 0 in the definition of `Nat`. The third line introduces an infix operator `::`, being a family of recursive generators: For each inhabitant `\head : T` it defines a recursive generator  
  `(head ::) : List[T] â†’ List[T]`  
that appends `head` to the right hand side argument `\tail : List[T]` so that non-empty lists can be generated by succesively appending elements to the `Empty` list. The set of possible values of  `List[T]` is therefore given by  
   `Empty, x :: Empty, x :: y :: Empty, x :: y :: z :: Empty, ...`  
for `x, y, z, ...` being of type `T`.  
Note that the arrow operator is right-associating, so `T â†’ (List[T] â†’ List[T])` can be written simply as `T â†’ List[T] â†’ List[T]`.

There is also a notion of inductive type family indexed over an other inductive type. For example, consider the type family of vectors of fixed length:
```
#Inductive Vec[\T] : Nat â†’ *
  Empty : (Vec[T] 0)
  (::)  : T â†’ Vec[T](\n) â†’ Vec[T](n')
```

Here `Vec[\T]` is not one type, but a whole family of types, one for each natural number `n`. The signature `: Nat â†’ *` means roughly â€œa function mapping natural numbers to typesâ€œ. The generator `Empty` satisfies the type `(Vec[T] 0)`. Generators `(head ::)` take a vector `\tail : (Vec[T] \n)` of _some_ length `\n` (notice the freshness sigil) and generate a vector of length `n' = n + 1`.

In this work we propose to introduce inductive types indexed over more general entities than inductive types themselves. We will call these entities indexes. Indexes are inductive types endowed with a (correct by construction, inductively generated) structure of a Reedy-category. We built upon an unpublished idea of Conor McBride presented in his Topos Institute Lecture [â€œCats and Types: Best Friends?â€œ](https://youtu.be/05IJ3YL8p0s). The typeformers satifying signature `I â†’ *` for an index `I` will semantically correspond to type-valued presheaves on `I` as Reedy-category.

We be able to define various very useful indices:
- The index CatCarrier so that `[\C : CatCarrier â†’ *] â‰¡ [\Ob : *, \Mor : Ob â†’ Ob â†’ *]`;
- For each notion of n-categories (globular, simplicial, cubical, etc) the index `nCatCarrier[n]` so that
```
  [\C : CatCarrier â†’ *] â‰¡ [
    \C.Cell(0) : *
    \C.Cell(1) : Ob â†’ Ob â†’ *
    \C.Cell(2) : Â·Â·Â·
    ...
    \C.Cell(n) : Â·Â·Â·
  ]
```   
  allowing to define n-categories and n-functors between them generically for all n. 
- The indices Î”âº and Î” such that typeformers satisfying the signatures `Î”âº â†’ *` and `Î” â†’ *` will correspond precisely to semi-simplicial and simplicial types respectively, which allows to define Ï‰-categories and various other interesting structures. In particular one covers the notion of very-dependent types as introduced by Jason J. Hickey and A. Kopylov, cf. [â€œFormal objects in type theory using very dependent types.â€](https://www.cs.cornell.edu/jyh/papers/fool3/paper.pdf).

Â§ The case of degeneracies
--------------------------

One type one often encounters is the type of number sequences containing only finite number of nonzero terms. For many practical applications one needs to have an upper bound on the number of nonzero entries, because it cannot be calculated in predictable time if unknown even in case of integer number sequences; in case of real number sequences it is not computable at all since the check an unknown decimal fraction represents a zero requires an infinite number of steps. So we need an inductive type `FiniteVec[\T : *, \zero : T][\size-bound : NatBound]` of sequences parametrized by the type `T` of its terms, marked `zero : T` element of that type and indexed over an upper bound to a number of non-zero terms.

The index `size-bound` ist not just a natural number. We want `FiniteVec[T,0][n]` to be a subtype of `FiniteVec[T,0][m]` whenever `n < m` and we want trailing zeroes to be ignored, i.e. sequences `(x :: y :: z)` and `(x :: y :: z :: 0)` to be equal.

In order to get there let us define the following index:
```
#Index NatBound
  0    : NatBound
  (_') : NatBound â†’ NatBound
  
  (\n : NatBound) |Extend(\m : Nat)âŸ© : (n.rec m (_'))
  
  |Extend(\m : Nat)âŸ© |Extend(\p : Nat)âŸ© â†¦ |Extend(n + m)âŸ©
```

The indices itself are freely generated by generators `0` and `(_')` just as natural numbers. But additionally there are embedding arrows `|Extend(m)âŸ©` going _from_ to each element `[n]`. Together with arrow source `[n]` the argument `m` of the arrow generator `|Extend(m)âŸ©` allows to compute which element the arrow goes _to_. Embedding arrows are required to go from structurally smaller elements to structurally larger ones, that is they comply with natural lexicographic ordering on the inhabitants of `NatBound`. For each pair of composable arrow generators we have to provide the computation rule for the composition (last line of the definition above), which has to be strictly associative. All in all, while it might be unclear which set of arrows goes into a particular element, but the set of right arrows going _from_ an element is a freely generated (inductive) type, and each arrow computes its target.

When one defines a type indexed over an index with embeddings, one has to provide degeneracy maps for each embedding:
```
#Inductive FinNatVec : NatBound â†’ *
   Empty : FinNatVec(0)
   (::)  : Nat â†’ FinNatVec(\b) â†’ (b')
   
   Empty            |Expand> â†¦ (Empty :: 0)
   (\head :: \tail) |Expand> â†¦ (\head :: (\tail |Expand>))
```

Â§ The case of dependencies
--------------------------

Simple mathematical structures are defined above a carrier which is simply a type:
```
#Structure Monoid[\T : *]
   unit : T
   (âˆ˜)  : T â†’ T â†’ T
   
   associator(\x \y \z : T)
   : (x âˆ˜ y) âˆ˜ z = x âˆ˜ (y âˆ˜ z)
   
   lt-unitor(\x : T) :
   : unit âˆ˜ x = x
   
   rt-unitor(\x : T) :
   : x âˆ˜ unit = x
```

More advanced mathematical structures seem not to have a single carrier:
```
#Structure Cat[\Ob : *, \Mor : Ob â†’ Ob â†’ *]
   id[\T]        : T
   (âˆ˜)[\A \B \C] : Mor[B][C] â†’ Mor[A][B] â†’ Mor[A][C]

   lt-unitor[\A \B](\f : Mor[A][B]) :
   : id[A] âˆ˜ f = f
   
   rt-unitor[\A \B](\f : Mor[A][B]) :
   : f âˆ˜ unit = f

   associator[\A \B \C \D](\f : Mor[A][B], \g : Mor[B][C], \h : Mor[C][D])
   : (h âˆ˜ g) âˆ˜ f = h âˆ˜ (g âˆ˜ f)
```

For a multitude of reasond it is desirable to represent the cast the whole parameter
list `[\Ob : *, \Mor : Ob â†’ Ob â†’ *]` as a single carrier `[C : CatCarrier â†’ *]`.

For this purpose we'll need an index type `CatCarrier` with dependency arrows:
```
#Index CatCarrier:
  Ob  : CatCarrier
  Mor : CatCarrier
  
  Mor.|SrcâŸ© : Ob
  Mor.|TgtâŸ© : Ob
```

Dependency arrows are exactly the same as embedding arrows except that they comply with inverse lexicographic ordering on the index, i.e. they are well-founded, all composable strings of dependency arrows are finite. It is precisely this finiteness that allows us introduce a special restriction operator (â†¾): any indexed typeformer `T : I â†’ *` and index `\i : I` the restriction (T â†¾ i) denotes a dependent record type: its extractors are given by dependency arrows form `i` and map to their respective types as given by `T` and previous entries of the dependent record. Now given an indexed typeformer `T : I â†’ *` we have `T(i) : (T â†¾ i) â†’ *`. For  indices with no dependent arrows, (T â†¾ i) is the unit type, thus one has simply `T(i) : *.

In particular, given a typeformer `T : CatCarrier â†’ * `, we have
```
T.Ob : *
T.Mor : (T â†¾ Mor) â†’ *
 â‡•
T.Mor : {src : Ob, tgt : Ob} â†’ *
```

Here is how one defines and an inductive type indexed by CatCarrier:
```
#Inductive SmallPointedTypes[\I : CatCarrier]
  PointedType(\T : ğ’°, \p : T) : SmallPointedTypes[Ob]
  PointedFunction(\X \Y : ğ’°, \x : X, \y : Y, f : (X â†’ Y), pointedness : ( f(x) = y ))
  : SmallPointedTypes[Mor][(Src â†¦ PointedType(X, x); Tgt â†¦ PointedType(Y, y)]
```

So far we only considered finite dependent indexes, let us consider an infinite one to illustrate the concept better.

The canonical example of an infinite index is given by Natâ±½:
```
#Index Natâ±½:
  0    : Natâ±½
  (_') : Natâ±½ â†’ Natâ±½ â†’ Natâ±½
  
  (\n)'.|Field(\m : Fin[m])âŸ© : m
  
  |Field(_)âŸ©|Field(\n)âŸ© : n
```

For a given `T : Natâ±½ â†’ *` the restriction `T â†¾ n` is the dependent record
```
field(0) : T(0)
field(1) : T(1)[ field(0) ]
field(2) : T(2)[ field(0) ][ field(1) ]
...
field(n - 1) : T(n - 1)[ field(0) ]...[ field(n - 2) ]
```

Thus, `T : Natâ±½ â†’ *` gives us precisely the so called very dependent types. A very-dependently typed sequence of such type `T` can be defined as follows:

```
#Coinductive DepSequence[\T : Natâ±½ â†’ *]
  head : T(0)
  tail : DepSequenceTail[T, 1, (field(0) â†¦ head)]

 where

#Coinductive DepSequenceTail[\T : Natâ±½ â†’ *][\i : Nat][\prefix : (T â†¾ n)]:
  head : T(i)[prefix]
  tail : DepSequenceTail[T, i', prefix ++ (field(i) â†¦ head)]
```

Analogously one can define the index Î”âº, so that `Î”âº â†’ *` are semi-simplicial types. By combining dependencies and degeneracies one can also define
the simplicial types. In general, we'll be able to form presheaves over any explicitly definable Reedy-categories, and with those, we can provide definitions for any higher categorical objects.

It still remains to be worked out which additional machinery is required to work with dependencies and embeddings properly: for example we used the operator `(++)` to extend a restriction `(T â†¾ n)` to a restriction `(T â†¾ n')`.

It also remains to be worked our how to provide codes for indexes and type families indexed over them so that we can mutually define type universes and index universes closed under them, and ensure the metatheoretical property that any type of our extended system eventually lands in a sufficiently large universe.

Â§ Type Formers and Signatures
-----------------------------

<<<
The name of the type is called a typeformer. The typeformer `Nat` adheres to the signature `Nat : *` which means `Nat` belongs to some sufficiently large type universe ğ’° and all universes above it: In type theory one cannot have _the_ universe ğ“¤, the type of all types, as it would necessarily contain itself which leads to a contradiction. Instead, one resorts to speaking of _a_ universe being a type of types not pretending to contain all types. For each universe ğ’° there is also a universe ğ’°âº that contains all inhabitants of ğ’° plus the ğ’° itself. Thus each universe generates a whole infinite cummulative hierarchy above itself:
```
ğ’° âŠ‚ ğ’°âº âŠ‚ ğ’°âºâº âŠ‚ Â·Â·Â·
```

By requiring an existance of a hierarchy of universes with certain closedness properties, one can ensure the metatheoretical property, that each definable type eventually lands in a sufficiently large universe and all universes above it.
<<<

The language of inductive type definitions and index definitions we used above can be thought of as a syntactic sugar.
Inductive definitions can be translated to codes (proper expressions inside the type theory) that generate inhabitants of sufficiently large universe types, so the language of type definitions is not a part of the core HOCC, it suffices to have correspoiding introduction rules for W-types in universes. There we'll have the basic universe ğ’° containing all finite types, the natural numbers, and closed under forming inductive and coinductive types (including dependent ones) by their codes, and a cumulative hierarchy generated by ğ’°:
```
ğ’° âŠ‚ ğ’°âº âŠ‚ ğ’°âºâº âŠ‚ Â·Â·Â·
```

With this approach types and type families are defined by expressions of type ğ’° (or ğ’°âºâ½â¿â¾ for some fixed `n`), polymorphic types become functions on some sufficiently large universe. We seemingly do not need any signatures, everything involves only bona fide types. But consider the typeformer `List`, which now has the bona fide type `List : ğ’° â†’ ğ’°`. But how do we apply it to a type living in a higher universe ğ’°âº? We need a lifting operator (â†‘) that to lift `List : ğ’° â†’ ğ’°` into `â†‘List : ğ’°âº â†’ ğ’°âº`. It turns out, lift operators must be indexed by the signatures of the type formers they lift, the source universe and the target universe. Thus the language of the signatures still must be a part of the core HOCC, but fully polymorphic (i.e. without restriction to a particular universe) typeformers are emulated by functions on universes and lifting.

So let us describe the language of typeformer signagures. A type former is either a simple type, or be polymorphic, or indexed, 

A valid typeformer signature is given by 
- `*`
- `index â†’ signature`
- `signature â†’ signature`

Here the signatures on the right hand side may depend on paramerers on the left hand side, and any type can be made into an index without any arrows by `[_]`-operator. Here are some examples of valid signatures:
```
  *
  [Nat] â†’ *
  * â†’ *
  * â†’ (Î”âº â†’ *)
  (T : *) â†’ Monoid[T] â†’ *
  
```
  
Here are some invalid ones:
```
  * â†’ [Nat]
  Î”âº â†’ Î”
```

There are two operations or signatures:
- specialization of signature to a given universe `U` is a type obtained by replacing all occurences or `*` by `U`.
- generalization of signature ğ”– by a signature ğ”… is a new signature, where one particular strictly-positive occurence of `*` by `(ğ”… â†’ *)`, which corresponds to transferring a construction from a universe to a presheaf valued in this universe.

Since (higher) topos structure is preserved by forming presheaves, in general, the lifting operator has four parameters besides the expression being lifted:
- a signature ğ”–,
- a universe `U`,
- a signature ğ”Š that generalizes ğ”–,
- a larger universe `U' âŠƒ U`

Lifting operator checks that the expression being lifted satisfies the type obtained by specializing ğ”– to U, and yields an expression of the type obtained by specializing ğ”Š to U'. The ability to replace any `*` in a strictly-positive position of signature by `(ğ”… â†’ *)` for any signature ğ”… is precisely what we mean by â€œ`*` is more than Typeâ€. We'll discuss that in depth in the section about handling categories below.


Â§ Parametric quantifiers
------------------------

In addition to the usual universal quantifier â€œfor eachâ€ `âˆ€(\x : X) Y[x]` HOCC has parametric quantifiers â€œfor all (independently of their values)â€ written as `â‹‚(\x : X) Y[x]`. Expressions of that type are inhabited by a special kind of lambda-abstractions:
```
 (\x :â° X) expr
```
The superscript zero 0 reflect to the fact that `x` is allowed to be used in the `expr` exactly zero times not counting usages in type annotations.

When regarding to values, the â‹‚-quantifier has more of an existential flavour:
```
c : â‹‚(\length : Nat) Vec[T][length]
```
means that `c` is a `T`-vector of some length. The length exists, that's all we know, and it cannot be extracted.

There are not much definable expressions of the type `âˆ€(\T : U) List[T]`. Since `T` is an unknown type we cannot excibit any of its inhabitants. In fact it might be empty. So the only definable expression of this type is `(\T : U) â†¦ Empty[T]` that produces an empty list of the given type. The variable `T` has only usages in type annotations, therefore this expression also typechecks against the type `â‹‚(\T : U) List[T]`.

Exactly for that reason it might be tempting to think that for any universe `U` the types `âˆ€(\T : U) Y[T]` and `â‹‚(\T : U) Y[T]` are contain the same definable values, i.e. the type `âˆ€(\T : U) Y[T]` can contain only constants of the type `Y[T]`. It can be shown to be false if we take `Y[T]` to be `U`. In this case the function `(\T : U) â†¦ U` satisfies to the type `âˆ€(\T : U) U`, but not `â‹‚(\T : U) U`.

Now we're ready to state that fully polymorphic functions/lemmas (i.e. the ones where polymorphism is not restricted to a particular universe) are not a part of the core HOCC, but are emulated by functions/lemmas parametrically quantified on universes and lifting.

We'll need a lifting operator for such functions/lemmas, that will be also signature indexed. Whenever we prove a statement
```
p : â‹‚(\T : U) âˆ€(\m : Monoid[T]) something
```
we would be able to transport it to larger universes U'.

Working directly with polymorphic typeformers and functions/lemmas is a syntactic sugar over the core HOCC in the very same way as the von Neumann-GÃ¶del-Bernays set-and-class theory NBG is a syntactic sugar on (conservative extension of) its core set theory ZFC. Being able to speak about polymorphic typeformers and functions/lemmas corresponds to being able to speak about classes. In particular, both provide a language to express constructions applicable to all groups, all categories and so on.


Â§ Handling Categories
---------------------

Let's consider categories as structures of the form
```
#Structure Cat[\Ob : *, \Mor : Ob â†’ Ob â†’ *]:
  id[\T : Ob] : Mor[T][T]
  compose[\X \Y \Z : Ob] : Mor[X][Y] â†’ Mor[Y][Z] â†’ Mor[X][Y]
  ... axioms
```

As we explained in depth above, we can define an index `CatCarrier` so that `Cat` can be seen as a structure endowing a carrier adhering to the signature `C : CatCarrier â†’ *`:
```
#Structure Cat[\C : CatCarrier â†’ *]:
  id[\T : C.Ob] : C.Mor[Src â†¦ T; Tgt â†¦ T]
  compose[\X \Y \Z : C.Ob]
  : C.Mor[Src â†¦ X; Tgt â†¦ Y] â†’ C.Mor[Src â†¦ Y; Tgt â†¦ Z] â†’ C.Mor[Src â†¦ X; Tgt â†¦ Y]
  ... axioms
```

In mathematics we frequently work with seemingly large categories of structured types, like category of all groups or all rings. 
In simple categories, `Mor[\src : Ob, tgt : Ob] : *` are just types, doubly indexed by `Ob`. In categories of structured objects they are parametrized by carriers and indexed by structures of their source and target:
```
Mor[\X \Y : *][\src : Group[X], \tgt : Group[Y]]
```

It looks quite monstrously, but we really can define categories of structured types without without any special gadgets:
```
#Structure CatOfStructuredTypes[
  \Ob : * â†’ *,
  \Mor : (SrcCarrier : *) â†’ (TgtCarrier : *)
   â†’ (SrcStructure : S[SrcCarrier])
   â†’ (TgtStructure : S[TgrCarrier])
   â†’ *]
... realization
```

Now we could define the category of all groups as an instance of `CatOfStructuredTypes[\Ob: Group, \Mor: GroupHomomorphism]`. If one specializes the quite complicated object to a fixed universe `U`, one obtains type isomorphic to the simple category `Cat[\Ob: Î£(T : U) Group[T], \Mor : SmallGroupHomomorphism]` of `U`-small groups. Thus, such complicated objects are in the fact quite amenable to work with considering specialization and lifting.

By using indexes (CatCarrier in particular), we wrap up the quite monstrous signature of `CatOfStructuredTypes`:
```
#Structure CatOfStructuredTypes[\Ğ¡ : CatCarrier â†’ (* â†’ *)].
```

In fact, with generalized (presheaf) lifting we can dispense with defining `CatOfStructuredTypes` altogether. We can just plug the typeformer of the group structure `Group : * â†’ *` into the spot where `Ob : *` is required, and the whole signature and everything else adjusts automagically. In fact we could use structures of more complicated carriers than just a type. For instance we could define the category of all categories.. well, almost. Because categories don't actually form a category, they form a 2-category.

Thankfully, our approach opens the road for defining carriers of n-categories uniformly:
```
#Index nCatCarrier(\n : Nat)
   Cell(\m : Fin[n]) : nCatCarrier
   ... dependency arrows
```

Then one can uniformoly define the n-categories themselves:
```
#Structure nCat[\n : Nat][\Ğ¡ : CatCarrier(n) â†’ *] 
  ... realization
```

so that `Cat â‰… nCat[1]`. Then one can also define n-functors between n-categories
```
#Structure nFunctor[\n : Nat][\Ğ¡ : CatCarrier[n']]
  ... realization
```

so that
```
  Cat â‰… nFunctor[1][Cell(0)]
  Functor â‰… nFunctor[1][Cell(1)]
  NatTrans â‰… nFunctor[1][Cell(2)]
```

Finally, for each `n` we can define the (n + 1)-category of n-categories and (n, m)-functors between them.

```
#Define nCAT(\n) : nCat[n'][nFunctor[n]]
  ... realization
```

We are unaware of any other foundational framework able to handle categories that naturally. We conjecture that within this approach one would eventially be able to formalize the whole corpus of http://ncatlab.org.

***

PART II
=======

Â§ What's so nice about algebraic theories?
------------------------------------------

Algebraic theories are very well understood. Definition of an (possibly multisorted) algebraic theory is a description of a finite-product category in terms of generators and relations, models are given by functors on that category, homomorphisms between models are given by natural transformations. Thus, models and homomorphisms between them form a category themselves.

For a single-sorted algebraic theory **Alg** one can always construct the purely inductive type `FreeAlg[T : *]` of free algebras on the set `T` of generators, and its quotients, i.e. models of **Alg** given in terms of generators and relations. The `FreeAlg[Fin[n]]` is guaranteed to be countable and have verifiable equality, that is this type is the syntactic model of the theory and consists of valid exressions with variables `n` in the language of the theory `Alg`. The free algebra on empty set of generators is the initial object in the category of models. This carries over to multi-sorted algebraic theories.

For every algebraic theory **Alg** one can define a derived theory called cosmification of **Alg**. One can define a notion of generalized models (and their homomorphisms) of **Alg** in every model of its cosmification, the notions of model homomorphism . For example, a monoid object in a multicategory. The category of models of **Alg** and carries structure of the cosmification of **Alg** and the same applies to categories of generalized models in any cosmification of **Alg** which is known as microcosm-macrocosm principle.

We claim to obtain analogous results for extended algebraic theories given as bidirectionally presented dependent type theories, which can be seen as descriptions of weak model categories in terms of generators and relations.



Â§ Extended Inductive Types and Extended Algebraic Theories
-------------------------------------------------------------

Ğ§Ğ¸ÑÑ‚Ğ¾ ÑĞ¸Ğ½Ñ‚ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ñ‚Ğ¸Ğ¿Ñ‹, Ñ‚Ğ°ĞºĞ¸Ğµ ĞºĞ°Ğº
```
#Synthetic Nat:
   Zero
   PosInt(\predecessor : Nat)
```
ÑÑ‚Ğ¾ Ñ‚Ğ¸Ğ¿Ñ‹, ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾ Ğ¿Ğ¾Ñ€Ğ¾Ğ¶Ğ´Ñ‘Ğ½Ğ½Ñ‹Ğµ Ğ½Ğµ Ğ±Ğ¾Ğ»ĞµĞµ Ñ‡ĞµĞ¼ ÑÑ‡Ñ‘Ñ‚Ğ½Ñ‹Ğ¼ Ğ½Ğ°Ğ±Ğ¾Ñ€Ğ¾Ğ¼ (Ğ²Ğ¾Ğ¾Ğ±Ñ‰Ğµ Ğ³Ğ¾Ğ²Ğ¾Ñ€Ñ Ñ€ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ñ‹Ñ…) Ğ¾Ğ±Ñ€Ğ°Ğ·ÑƒÑÑ‰Ğ¸Ñ…. 

Ğ§Ğ¸ÑÑ‚Ğ¾ ÑĞ¸Ğ½Ñ‚ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ñ‹, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ·Ñ‹ĞºĞ¸, Ğ²Ğ¾Ñ‚ Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑĞ·Ñ‹ĞºĞ° Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ â€œĞºĞ°Ğº Ğ½Ğ° ĞºĞ°Ğ»ÑŒĞºÑƒĞ»ÑÑ‚Ğ¾Ñ€Ğµ ÑĞ¾ ÑĞºĞ¾Ğ±ĞºĞ°Ğ¼Ğ¸â€:
```
Synthetic Expr:
   Neg(\a : Expr)
   Add(\a \b : Expr)
   Const(\c : Float)
```
Ğ˜Ñ‚Ğ¾Ğ³Ğ¾ Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ¾ Ğ»Ğ¸Ğ±Ğ¾ ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ğ° (Ñ‡Ğ¸ÑĞ»Ğ¾ Ñ Ğ¿Ğ»Ğ°Ğ²Ğ°ÑÑ‰ĞµĞ¹ Ğ·Ğ°Ğ¿ÑÑ‚Ğ¾Ğ¹), Ğ»Ğ¸Ğ±Ğ¾ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ¸ ÑĞ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Add Ğ¸ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Neg. ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚Ğµ Ğ²Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ, Ñ‡Ñ‚Ğ¾ Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ¾ Ñ‚ÑƒÑ‚ Ğ½ĞµÑ‚ Ğ½Ğ¸Ñ‡ĞµĞ³Ğ¾ Ğ¾ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ¾Ğ² Ğ¸ Ñ€Ğ°ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ ÑĞºĞ¾Ğ±Ğ¾Ğº: Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ² Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑÑƒÑÑ‰ĞµĞ¼ Ğ½Ğ°Ñ ÑĞ¼Ñ‹ÑĞ»Ğµ â€” ÑÑ‚Ğ¾ ÑƒĞ¶Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾, Abstract Syntax Tree.

Ğ¢ÑƒÑ‚ Ğ½Ğ°Ğ´Ğ¾ Ğ¿Ğ¾Ğ´Ñ‡ĞµÑ€ĞºĞ½ÑƒÑ‚ÑŒ Ñ€Ğ°Ğ·Ğ½Ğ¸Ñ†Ñƒ Ğ¼ĞµĞ¶Ğ´Ñƒ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ ÑĞ·Ñ‹ĞºĞ°Ğ¼Ğ¸ Ğ¸ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸. Ğ¢ĞµĞ¾Ñ€Ğ¸Ñ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ·Ñ‹ĞºĞ¾Ğ² (Ğ² Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸ĞºĞµ) Ğ·Ğ°Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ÑÑ ĞºĞ°Ğº Ñ€Ğ°Ğ· Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸ÑĞ¼Ğ¸ ĞºĞ°Ğº Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑĞ¼Ğ¸ Ğ±ÑƒĞºĞ², Ñ†Ğ¸Ñ„Ñ€, Ğ·Ğ½Ğ°Ñ‡ĞºĞ¾Ğ² Ğ¸ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ğ¾Ğ²: Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ÑĞ·Ñ‹ĞºĞ° Ğ°Ñ€Ğ¸Ñ„Ğ¼ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ â€” ÑÑ‚Ğ¾ ĞºĞ°Ğº Ñ€Ğ°Ğ· Ğ¿Ñ€Ğ¾ ÑĞ±Ğ°Ğ»Ğ°Ğ½ÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ ÑĞºĞ¾Ğ±Ğ¾Ğº Ğ¸ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹, Ğ¿Ñ€Ğ¾ Ñ‚Ğ¾ ĞºĞ°ĞºĞ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ² ÑĞ²Ğ»ÑÑÑ‚ÑÑ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¼Ğ¸ Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸ÑĞ¼Ğ¸, ĞºĞ°Ğº Ğ¸Ñ… Ñ€Ğ°ÑĞ¿Ğ°Ñ€ÑĞ¸Ñ‚ÑŒ Ğ² ÑĞ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾ Ğ¸ ĞºĞ°Ğº ĞµÑ‰Ñ‘ Ğ½Ğ° ÑÑ‚Ğ°Ğ¿Ğµ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ° ÑĞ·Ñ‹ĞºĞ° Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ¸ÑĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ²ÑƒÑĞ¼Ñ‹ÑĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸. Ğ¢ĞµĞ¾Ñ€Ğ¸Ñ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ·Ñ‹ĞºĞ¾Ğ² â€” ÑÑ‚Ğ¾ ÑƒĞ¶Ğµ Ğ½Ğ° ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ²Ñ‹ÑˆĞµ, ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ Ñ ÑƒĞ¶Ğµ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ ÑĞ¸Ğ½Ñ‚Ğ°ĞºÑĞ¸Ñ‡ĞµÑĞºĞ¸Ğ¼Ğ¸ Ğ´ĞµÑ€ĞµĞ²ÑŒÑĞ¼Ğ¸.

Ğ’ ÑƒĞ·ĞºĞ¾Ğ¼ ÑĞ¼Ñ‹ÑĞ»Ğµ type theory studies ÑÑ‚Ğ¾ Ğ² Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚Ğ¸ Ñ‚ĞµĞ¾Ñ€Ğ¸Ñ Ñ‚Ğ¸Ğ¿Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ·Ñ‹ĞºĞ¾Ğ². Ğ§Ñ‚Ğ¾ Ñ‚Ğ°ĞºĞ¾Ğµ Ñ‚Ğ¸Ğ¿Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ·Ñ‹Ğº? Ğ­Ñ‚Ğ¾ ĞºĞ¾Ğ³Ğ´Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ ÑĞ±Ğ¾Ñ€ĞºĞµ Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ¸Ğ· Ğ¿Ğ¾Ğ´Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ Ñƒ Ğ½Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ Ğ½Ğ° Ñ‚Ğ¾, Ñ‡Ñ‚Ğ¾ ĞºÑƒĞ´Ğ° Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ²Ñ‚Ñ‹ĞºĞ°Ñ‚ÑŒ. Ğ”Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼, Ğ² Ğ½Ğ°ÑˆĞµĞ¼ ÑĞ·Ñ‹ĞºĞµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ Ğ¿Ğ¾ÑĞ²Ğ¸Ñ‚ÑÑ Ğ´Ğ²Ğ° Ñ‚Ğ¸Ğ¿Ğ° Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹:
```
#Synthetic ExprType
  Numeric
  Boolean
```
Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ñ‚Ğ¸Ğ¿ Ğ²Ñ‹Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ±ÑƒĞ´ĞµÑ‚ â€œĞ¸Ğ½Ğ´ĞµĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½â€ Ñ‚Ğ¸Ğ¿Ğ¾Ğ¼ ExprType:
```
#Synthetic Expr[\type : ExprType]:
   Const(\c : Float) : Expr[Numeric]
   Neg(\a : Expr[Numeric]) : Expr[Numeric]
   Add(\a \b : Expr[Numeric]) : Expr[Numeric]

   Not(\a : Expr[Boolean]) : Expr[Boolean]
   And(\a \b : Expr[Boolean]) : Expr[Boolean]

   CheckEquals(\a \b : Exp[Numeric]) : Expr[Boolean]
   CheckLess(\a \b : Exp[Numeric]) : Expr[Boolean]

   IfThenElse(\cond : Exp[Boolean], \a \b : Exp[Numeric])
    : Expr[Numeric]
```

... Ñ‚ĞµĞ¿ĞµÑ€ÑŒ Ğ½Ğ°Ğ´Ğ¾ ÑĞ´ĞµĞ»Ğ°Ñ‚ÑŒ STLC, Ğ½Ğ° ĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğµ Ğ²Ğ²ĞµÑÑ‚Ğ¸ Ñ€ĞµĞ´ÑƒĞºÑ†Ğ¸Ğ¸ Ğ¸ Ğ±Ğ¸Ğ´Ğ¸Ñ€ĞµĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ

Â§ Functorial Semantics of Extended Algebraic Theories
-----------------------------------------------------

...

Â§ Conclusion and Future Work
----------------------------

ĞœÑ‹ Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ñ€Ğ°Ğ»Ğ¸ÑÑŒ Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ±Ğ»Ğ¸Ğ·ĞºĞ¾ Ğº Ñ‚Ğ¾Ğ¼Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ¼ĞµÑ‚ÑŒ ÑƒĞ½Ğ¸Ğ²Ğ°Ğ»ĞµĞ½Ñ‚Ğ½ÑƒÑ (Ñ Ñ€Ğ°Ğ²ĞµĞ½ÑÑ‚Ğ²Ğ¾Ğ¼ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºĞ° Ğ¸ Ğ±ĞµĞ· Ğ²ÑÑĞºĞ¾Ğ¹ strict equality) Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ñ‚ĞµĞ¾Ñ€Ğ¸Ñ Ñ‚Ğ¸Ğ¿Ğ¾Ğ², ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼ÑƒÑ Ñ Ğ°ĞºÑĞ¸Ğ¾Ğ¼Ğ¾Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°, Ğ¸ Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ¾Ğ¼ Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ²Ñ‹Ñ€Ğ°Ğ·Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ² Ğ½ĞµĞ¹ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ»Ğ¸ ÑĞ¸Ğ½Ñ‚ĞµÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ½Ñ‹Ñ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ·Ñ‹ĞºĞ¾Ğ², Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ make precise sense of macrocosm-microcosm principle Ğ´Ğ»Ñ Ğ°Ğ»Ğ³ĞµĞ±Ñ€Ğ°Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ñ‚ĞµĞ¾Ñ€Ğ¸Ñ…, Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ĞµÑÑŒ ncatlab Ğ²Ğ¼ĞµÑÑ‚Ğµ ÑĞ¾ Sketches of Elefant, Higher Topos Theory, SGA, EGA Ğ¸ Stacks Project, ÑƒĞ´Ğ¾Ğ±Ğ½Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ñ ĞµÑÑ‚ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ Ğ²Ğ¾Ğ·Ğ½Ğ¸ĞºĞ°ÑÑ‰Ğ¸Ğ¼Ğ¸ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ğ¼Ğ¸ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼Ğ¸, Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ĞµÑ‰ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ Ñ‡Ğ¸ÑĞ»Ğ° Ğ²Ğ¼ĞµÑÑ‚Ğµ Ñ ĞºĞ¾Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¼ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ¼, Ğ¸ Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ¾Ğ¼ Ğ² Ğ½ĞµĞ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ»Ğ¾ eating itself Ğ¿Ğ¾ ÑÑ…ĞµĞ¼Ğµ Gentle art of levitation, Ğ¸ Ğ²ÑÑ‘ ÑÑ‚Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ Ñ Ğ°ĞºÑĞ¸Ğ¾Ğ¼Ğ¾Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°.

Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑˆĞ°Ğ³ â€” ÑĞ´ĞµĞ»Ğ°Ñ‚ÑŒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ñ ÑÑ‚Ğ¸Ğ¼ Ğ±Ñ‹Ğ»Ğ¾ ÑƒĞ´Ğ¾Ğ±Ğ½Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ: Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Î½-rules, Ğ¾Ñ€Ğ½Ğ°Ğ¼ĞµĞ½Ñ‚Ñ‹ Ğ¸ ÑĞ°Ğ±Ñ‚Ğ°Ğ¹Ğ¿Ğ¸Ğ½Ğ³, Ñ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¼ Ğ±Ñ‹Ğ»Ğ¾ Ğ±Ñ‹ Ğ¾Ñ‡ĞµĞ½ÑŒ ÑƒĞ´Ğ¾Ğ±Ğ½Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ.

Ğ•Ñ‰Ñ‘ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ â€” Ğ¿Ñ€Ğ¸Ğ´ÑƒĞ¼Ğ°Ñ‚ÑŒ ĞºĞ°Ğº Ğ¸Ğ·Ğ¾Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ LEM/AC Ñ‚Ğ°Ğ¼, Ğ³Ğ´Ğµ ÑÑ‚Ğ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾, Ğ¸ ĞºĞ°Ğº embeddiÑ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ DSLĞ¸.

Ğ•Ñ‰Ñ‘ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ â€” Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ linear types Ğ¸ Ğ¿Ğ¾Ğ½ÑÑ‚ÑŒ/Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Partial Algebraic Theories over a Partial Field, Ñ‚Ğ°ĞºĞ¸Ğµ Ñ‡Ñ‚Ğ¾ ĞºĞ¾Ğ³Ğ´Ğ° Ğ¼Ñ‹ Ğ¸Ñ… Ñ€Ğ°ÑÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ½Ğ°Ğ´ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¼ Ğ¿Ğ¾Ğ»ĞµĞ¼ ğ”½â‚, Ğ¾Ğ½Ğ¸ ÑĞ²Ğ¾Ğ´ÑÑ‚ÑÑ Ğº Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¼ Ğ°Ğ»Ğ³ĞµĞ±Ñ€Ğ°Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼ Ñ‚ĞµĞ¾Ñ€Ğ¸ÑĞ¼. (https://arxiv.org/pdf/2011.06644.pdf)
